<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MayaMax</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
let images = new Array(20).fill(null);
const transparencyThreshold = 128;
const numOfStreams = 3000;
let imgCenter; 
let pointImageOverlapCache = {};  
let circleDiameter;
let streamGroups = [];
let desiredStreamCounts = [];
let totalStreamsToGenerate = 0;
const REF_AREA = 1920 * 1080;
const BASE_SPEED = .01;
const LOG_SCALE_FACTOR = .95;
let selectedColorSet;
let MARGIN;
let isColorCycling = false;
let baseHue = 0;
const COLOR_CYCLE_SPEED = 1.1;

// Define initialization rectangles
const initRectangles = [
    { width: 100, height: 20, x: 57, y: 29 },  // hatStripe.png
    { width: 86, height: 39, x: 57, y: 25 },  // hatTop.png
    { width: 111, height: 74, x: 55, y: 30 },  // hatBottom.png
    { width: 89, height: 74, x: 48, y: 85 },  // pantsLeft.png
    { width: 70, height: 46, x: 62, y: 80 },  // pantsMid.png
    { width: 94, height: 74, x: 74, y: 85 },  // pantsRight.png
    { width: 85, height: 75, x: 59, y: 84 },   // hands.png
    { width: 57, height: 49, x: 74, y: 84 },   // cuffRight.png
    { width: 57, height: 49, x: 54, y: 82 },   // cuffLeft.png
    { width: 181, height: 45, x: 47, y: 79 },  // scarf7.png
    { width: 181, height: 56, x: 47, y: 73 },  // scarf6.png
    { width: 181, height: 65, x: 47, y: 65 },  // scarf5.png
    { width: 181, height: 84, x: 47, y: 57 },  // scarf4.png
    { width: 181, height: 63, x: 47, y: 56 },  // scarf3.png
    { width: 148, height: 78, x: 47, y: 35 },  // scarf2.png
    { width: 156, height: 81, x: 54, y: 47 },  // scarf1.png
    { width: 50, height: 26, x: 61, y: 46 },   // mouth.png
    { width: 23, height: 12, x: 69, y: 41 },   // rightEye.png
    { width: 23, height: 12, x: 60, y: 41 },   // leftEye.png
    { width: 93, height: 75, x: 56, y: 38 }    // face.png
];

const colorSets = [
    [
        [225, 125, 114],    // hatStripe.png - Golden yellow
        [30, 127, 155],     // hatTop.png - Brown
        [29, 126, 154],     // hatBottom.png - Brown
        [108, 17, 29],    // pantsLeft.png - Navy blue
        [107, 17, 29],    // pantsMid.png - Navy blue
        [108, 17, 30],    // pantsRight.png - Navy blue
        [256, 221, 181],  // hands.png - Skin tone
        [131, 30, 45],  // cuffRight.png - Light gray
        [130, 21, 36],  // cuffLeft.png - Light gray
        [103, 76, 118],    // scarf7.png - Orange
        [24, 83, 128],    // scarf6.png - Light orange
        [19, 96, 86],    // scarf5.png - Orange
        [219, 102, 83],    // scarf4.png - Dark orange
        [231, 86, 118],    // scarf3.png - Orange
        [170, 18, 40],    // scarf2.png - Burnt orange
        [219, 98, 80],    // scarf1.png - Deep orange
        [200, 50, 75],    // mouth.png - Lip red
        [0, 0, 0],     // rightEye.png - Dark gray
        [0, 0, 1],     // leftEye.png - Dark gray
        [255, 220, 180]   // face.png - Light skin tone
    ]
];

function calculateMargin() {
    MARGIN = Math.min(windowWidth, windowHeight) * 0.1;
}

function calculateImageDimensions() {
    const aspectRatio = 326/446;  // Original aspect ratio
    const maxWidth = windowWidth;
    const maxHeight = windowHeight;
    
    // Calculate dimensions that maintain aspect ratio while fitting in the window
    let rectWidth, rectHeight;
    if (maxWidth / maxHeight > aspectRatio) {
        // Height is the limiting factor
        rectHeight = maxHeight;
        rectWidth = rectHeight * aspectRatio;
    } else {
        // Width is the limiting factor
        rectWidth = maxWidth;
        rectHeight = rectWidth / aspectRatio;
    }
    
    // Calculate image dimensions (10.5% larger than rectangle)
    const imageWidth = rectWidth * 1.105;
    const imageHeight = rectHeight * 1.105;
    
    return {
        rectWidth,
        rectHeight,
        imageWidth,
        imageHeight
    };
}

function preload() {
    calculateMargin();
    let dimensions = calculateImageDimensions();
    
    let imageNames = [
        "hatStripe.png", "hatTop.png", "hatBottom.png", "pantsLeft.png", "pantsMid.png",
        "pantsRight.png", "hands.png", "cuffRight.png", "cuffLeft.png", "scarf7.png",
        "scarf6.png", "scarf5.png", "scarf4.png", "scarf3.png", "scarf2.png", 
        "scarf1.png", "mouth.png", "rightEye.png", "leftEye.png", "face.png"
    ];
    
    for (let i = 0; i < imageNames.length; i++) {
        loadImage(imageNames[i], img => {
            let scaleFactor = dimensions.imageHeight / img.height;
            img.resize(img.width * scaleFactor, img.height * scaleFactor);
            images[i] = img;
        });
    }
}

function getCurrentAttractMode() {
    if (streamGroups.length === 0 || streamGroups[0].length === 0) {
        return true;
    }
    return streamGroups[0][0].attractMode;
}

function generateStreams() {
    let areaRatio = (windowWidth * windowHeight) / REF_AREA;
    let adjustedNumOfStreams = Math.round(numOfStreams * areaRatio);

    // Distribution percentages for each image (must add up to 1.0)
    const percentages = [
        0.03,  // hatStripe.png
        0.03,  // hatTop.png
        0.05,  // hatBottom.png
        0.04,  // pantsLeft.png
        0.02,  // pantsMid.png
        0.04,  // pantsRight.png
        0.06,  // hands.png
        0.04,  // cuffRight.png
        0.04,  // cuffLeft.png
        0.07,  // scarf7.png
        0.07,  // scarf6.png
        0.07,  // scarf5.png
        0.05,  // scarf4.png
        0.05,  // scarf3.png
        0.07,  // scarf2.png
        0.08,  // scarf1.png
        0.005,  // mouth.png
        0.02,  // rightEye.png
        0.02,  // leftEye.png
        0.125   // face.png
    ];  // Total: 1.0 (100%)

    desiredStreamCounts = [];

    for (let j = 0; j < percentages.length; j++) {
        let desiredCountForImage = Math.round(adjustedNumOfStreams * percentages[j]);
        desiredStreamCounts.push(desiredCountForImage);
    }
    
    totalStreamsToGenerate = adjustedNumOfStreams;
}

function setup() {
    createCanvas(windowWidth, windowHeight);
    imgCenter = createVector(width / 2, height / 2);
    background(0, 0, 0);
    
    for (let i = 0; i < 20; i++) {
        streamGroups.push([]);
    }

    generateStreams();
    selectedColorSet = colorSets[0];
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    imgCenter.set(width / 2, height / 2);

    calculateMargin();
    let dimensions = calculateImageDimensions();
    
    for (let i = 0; i < images.length; i++) {
        let img = images[i];
        if (img) {
            let scaleFactor = dimensions.imageHeight / img.height;
            img.resize(img.width * scaleFactor, img.height * scaleFactor);
        }
    }
    
    imgCenter.set(width / 2, height / 2);
    
    generateStreams();
}

function isOverAnyImageCached(point) {
    let cacheKey = `${point.x},${point.y}`;

    if (pointImageOverlapCache.hasOwnProperty(cacheKey)) {
        return pointImageOverlapCache[cacheKey];
    }

    let result = isOverAnyImage(point);
    pointImageOverlapCache[cacheKey] = result;

    return result;
}

function draw() {
    if (!selectedColorSet) return;
    
    background(0, 0, 0);
    pointImageOverlapCache = {};
    // drawTransparentCircle();

    if (isColorCycling) {
        baseHue = (baseHue + COLOR_CYCLE_SPEED) % 360;
        selectedColorSet = generateColorSet();
        updateStreamColors();
    }

    adjustStreams();

    for (let streams of streamGroups) {
        for (let s of streams) {
            s.update();
            s.display();
        }
    }
}

function adjustStreams() {
    if (!selectedColorSet) return;

    for (let j = 0; j < 20; j++) {
        while (streamGroups[j].length < desiredStreamCounts[j]) {
            let samplePoint = streamGroups[j].length > 0 ? random(random(streamGroups[j]).points) : null;
            streamGroups[j].push(new Stream(selectedColorSet[j], j, samplePoint));
        }

        while (streamGroups[j].length > desiredStreamCounts[j]) {
            let lastStream = streamGroups[j][streamGroups[j].length - 1];
            if (lastStream) {
                lastStream.fade();
                if (lastStream.alpha <= 0) {
                    streamGroups[j].pop();
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }
}

function drawTransparentCircle() {
    fill(255, 255, 255, 30);
    noStroke();

    ellipse(width / 2, height / 2, circleDiameter * 2.1);
    ellipse(width / 2, height / 2, circleDiameter * 1.9);
    ellipse(width / 2, height / 2, circleDiameter * 1.7);
    ellipse(width / 2, height / 2, circleDiameter * 1.5);
    ellipse(width / 2, height / 2, circleDiameter * 1.3);
    ellipse(width / 2, height / 2, circleDiameter * 1.1);
    ellipse(width / 2, height / 2, circleDiameter * .9);
    ellipse(width / 2, height / 2, circleDiameter * .7);
}

function isInsideCircle(point) {
    return dist(point.x, point.y, imgCenter.x, imgCenter.y) <= circleDiameter / 1.6;
}

function isInsideRect(point) {
    const dimensions = calculateImageDimensions();
    const rectLeft = imgCenter.x - dimensions.rectWidth/2;
    const rectRight = imgCenter.x + dimensions.rectWidth/2;
    const rectTop = imgCenter.y - dimensions.rectHeight/2;
    const rectBottom = imgCenter.y + dimensions.rectHeight/2;
    
    return point.x >= rectLeft && 
           point.x <= rectRight && 
           point.y >= rectTop && 
           point.y <= rectBottom;
}

function mousePressed() {
    isColorCycling = !isColorCycling;
}

function keyPressed() {
    if (key >= '1' && key <= '4') {
        let paletteIndex = parseInt(key) - 1;
        selectedColorSet = colorSets[paletteIndex];
        updateStreamColors();
    }
}

function updateStreamColors() {
    for (let j = 0; j < streamGroups.length; j++) {
        for (let stream of streamGroups[j]) {
            stream.color = selectedColorSet[j];
        }
    }
}

// function resetStreams() {
//     for (let j = 0; j < 4; j++) {
//         streamGroups[j] = [];
//     }
//     generateStreams();
// }

class Stream {
    constructor(color, assignedImageIdx, startPoint = null) {
        this.color = color;
        this.points = [];
        this.noiseOffset = random(1000);
        this.currentAngle = random(TWO_PI);
        this.attractMode = getCurrentAttractMode();
        this.assignedImageIdx = assignedImageIdx;
        this.initStream(startPoint);
        this.insideImage = this.isOverAssignedImage(this.points[0]);
        this.alpha = 255;
    }
    
    changeMode() {
        this.attractMode = !this.attractMode;
    }

    fade() {
        this.alpha -= 200;
    }
  
    isOverAnyImage(point) {
        return isOverAnyImageCached(point);
    }

    initStream(startPoint = null) {
        if (startPoint) {
            this.points.push(startPoint);
        } else {
            let startX, startY;
            let attempts = 0;
            const maxAttempts = 200;
            
            do {
                // Get the initialization rectangle for this stream
                const rect = initRectangles[this.assignedImageIdx];
                if (!rect) break;
                
                // Get the main rectangle dimensions
                const dimensions = calculateImageDimensions();
                
                // Calculate the actual pixel dimensions of the init rectangle
                const rectPixelWidth = (rect.width / 100) * dimensions.rectWidth;
                const rectPixelHeight = (rect.height / 100) * dimensions.rectHeight;
                
                // Calculate the center position of the init rectangle
                const rectCenterX = imgCenter.x + ((rect.x - 50) / 100) * dimensions.rectWidth;
                const rectCenterY = imgCenter.y + ((rect.y - 50) / 100) * dimensions.rectHeight;
                
                // Calculate the bounds of the init rectangle
                const rectLeft = rectCenterX - rectPixelWidth / 2;
                const rectRight = rectCenterX + rectPixelWidth / 2;
                const rectTop = rectCenterY - rectPixelHeight / 2;
                const rectBottom = rectCenterY + rectPixelHeight / 2;
                
                // Generate random point within the init rectangle bounds
                startX = random(rectLeft, rectRight);
                startY = random(rectTop, rectBottom);
                
                attempts++;
            } while (
                attempts < maxAttempts && 
                (!this.isOverAssignedImage(createVector(startX, startY)) || 
                !isInsideRect(createVector(startX, startY)))
            );
            
            // If we couldn't find a valid point, fall back to random position
            if (attempts >= maxAttempts) {
                startX = random(width);
                startY = random(height);
            }
            
            this.points.push(createVector(startX, startY));
        }
    }

    isOutsideAllImages(point) {
        return !this.isOverAnyImage(point);
    }

    isOverAnyImage(point) {
        for (let img of images) {
            if (this.isOverImage(point, img)) return true;
        }
        return false;
    }

    isOverAssignedImage(point) {
        return this.isOverImage(point, images[this.assignedImageIdx]);
    }

    isOverImage(point, img) {
        let imgX = point.x - (width / 2 - img.width / 2);
        let imgY = point.y - (height / 2 - img.height / 2);
        if (imgX >= 0 && imgX < img.width && imgY >= 0 && imgY < img.height) {
            let pixelColor = img.get(imgX, imgY);
            return alpha(pixelColor) > transparencyThreshold && isInsideRect(point);
        }
        return false;
    }
  
    stayWithinBounds(point) {
        const buffer = 5;
        if (point.x <= buffer || point.x >= width - buffer) {
            this.currentAngle = PI - this.currentAngle;
        }
        if (point.y <= buffer || point.y >= height - buffer) {
            this.currentAngle = -this.currentAngle;
        }
    }

    get totalStreamsCount() {
        let totalStreams = 0;
        for (let streams of streamGroups) {
            totalStreams += streams.length;
        }
        return totalStreams;
    }

    update() {
        let lastPoint = this.points[this.points.length - 1];
        let newPoint;

        // Smoother speed calculation with less variation
        let speed = this.attractMode ? 
            BASE_SPEED + (LOG_SCALE_FACTOR * 0.5) * Math.log(this.totalStreamsCount + 1) : 
            8;  // Reduced from 12 to 8 for smoother repulsion

        if (this.attractMode) {
            if (this.isOutsideAllImages(lastPoint) || this.insideImage || this.isOverAssignedImage(lastPoint)) {
                // Smoothly interpolate between current angle and target angle
                let targetAngle = this.calculateAngleTowardsImage(lastPoint, this.assignedImageIdx);
                let angleDiff = (targetAngle - this.currentAngle + PI) % TWO_PI - PI;
                this.currentAngle += angleDiff * 0.1;  // Gradual turn
            }
        } else {
            if (this.isOverAnyImage(lastPoint)) {
                // Smoothly interpolate between current angle and escape angle
                let targetAngle = this.calculateAngleAwayFromClosestImageCenter(lastPoint);
                let angleDiff = (targetAngle - this.currentAngle + PI) % TWO_PI - PI;
                this.currentAngle += angleDiff * 0.1;  // Gradual turn
            }
        }

        // Reduced angle variation for smoother movement
        let angleVariation = map(noise(this.noiseOffset), 0, 1, -PI/8, PI/8);  // Reduced from PI to PI/8
        this.currentAngle += angleVariation;

        newPoint = p5.Vector.fromAngle(this.currentAngle).mult(speed).add(lastPoint);

        if (this.attractMode && this.insideImage && !this.isOverAssignedImage(newPoint)) {
            this.currentAngle += PI;
            newPoint = p5.Vector.fromAngle(this.currentAngle).mult(speed).add(lastPoint);
        }

        this.stayWithinBounds(newPoint);

        this.points.push(newPoint);
        this.noiseOffset += 0.0005;  // Reduced from 0.001 for smoother noise variation

        if (this.points.length > 100) {
            this.points.shift();
        }

        this.insideImage = this.isOverAssignedImage(lastPoint);
    }

    calculateAngleAwayFromClosestImageCenter(point) {
        let closestDistance = Infinity;
        let closestImageCenter;

        for (let img of images) {
            let distance = dist(point.x, point.y, imgCenter.x, imgCenter.y);
            if (distance < closestDistance && this.isOverImage(point, img)) {
                closestDistance = distance;
                closestImageCenter = imgCenter;
            }
        }

        if (closestImageCenter) {
            return p5.Vector.sub(point, closestImageCenter).heading();
        }
        
        return random(TWO_PI);
    }

    calculateAngleTowardsImage(point, imgIdx) {
        if (this.insideImage) {
            return random(TWO_PI);
        }
        
        // Get the assigned image
        const img = images[imgIdx];
        if (!img) return random(TWO_PI);
        
        // Calculate image bounds
        const imgX = width / 2 - img.width / 2;
        const imgY = height / 2 - img.height / 2;
        
        // Calculate a random point within the image bounds
        const targetX = random(imgX, imgX + img.width);
        const targetY = random(imgY, imgY + img.height);
        
        // Calculate angle towards the random point in the image
        return atan2(targetY - point.y, targetX - point.x);
    }

    display() {
        noFill();
        let alphaValue = this.alpha;
        if (!this.isOverAssignedImage(this.points[this.points.length - 1])) {
            alphaValue = this.alpha * 0.3; // Reduce brightness to 30% when not over assigned image
        }
        stroke(this.color[0], this.color[1], this.color[2], alphaValue);
        strokeWeight(.5);
        beginShape();
        for (let pt of this.points) {
            vertex(pt.x, pt.y)
        }
        endShape();
    }
}

function rgbToHsb(r, g, b) {
    r = r / 255;
    g = g / 255;
    b = b / 255;
    
    let max = Math.max(r, g, b);
    let min = Math.min(r, g, b);
    let d = max - min;
    
    let h;
    if (max === min) {
        h = 0;
    } else if (max === r) {
        h = (60 * ((g - b) / d) + 360) % 360;
    } else if (max === g) {
        h = (60 * ((b - r) / d) + 120) % 360;
    } else {
        h = (60 * ((r - g) / d) + 240) % 360;
    }
    
    let s = max === 0 ? 0 : d / max;
    let v = max;
    
    return [h, s * 100, v * 100];
}

function generateColorSet() {
    if (!isColorCycling) {
        return colorSets[0];
    }
    
    let colors = [];
    for (let i = 0; i < 20; i++) {
        let originalColor = colorSets[0][i];
        let [h, s, v] = rgbToHsb(originalColor[0], originalColor[1], originalColor[2]);
        let newHue = (h + baseHue) % 360;
        colors.push(hsbToRgb(newHue, s, v));
    }
    return colors;
}

function hsbToRgb(h, s, v) {
    h = h % 360;
    s = s / 100;
    v = v / 100;
    
    let c = v * s;
    let x = c * (1 - Math.abs((h / 60) % 2 - 1));
    let m = v - c;
    
    let r, g, b;
    
    if (h < 60) {
        [r, g, b] = [c, x, 0];
    } else if (h < 120) {
        [r, g, b] = [x, c, 0];
    } else if (h < 180) {
        [r, g, b] = [0, c, x];
    } else if (h < 240) {
        [r, g, b] = [0, x, c];
    } else if (h < 300) {
        [r, g, b] = [x, 0, c];
    } else {
        [r, g, b] = [c, 0, x];
    }
    
    return [
        Math.round((r + m) * 255),
        Math.round((g + m) * 255),
        Math.round((b + m) * 255)
    ];
}
    </script>
</body>

</html>