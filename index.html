<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maya</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
let images = new Array(17).fill(null);
const transparencyThreshold = 128;
const numOfStreams = 2000;
let imgCenter; 
let pointImageOverlapCache = {};  
let circleDiameter;
let streamGroups = [];
let desiredStreamCounts = [];
let totalStreamsToGenerate = 0;
const REF_AREA = 1920 * 1080;
const BASE_SPEED = .01;
const LOG_SCALE_FACTOR = .95;
let selectedColorSet;
let MARGIN;
let isColorCycling = false;
let baseHue = 0;
const COLOR_CYCLE_SPEED = 1.1;

function extractDominantColor(img) {
    // Check if this is mouth.png or scarf3.png
    if (img === images[13]) { // mouth.png
        return [200, 50, 75]; // Lip red color
    }
    if (img === images[10]) { // scarf3.png
        return [255, 165, 0]; // Orange color
    }

    // For all other images, sample points to find a non-transparent color
    const samplePoints = 100;
    let validColors = [];
    
    // Define margin to ignore (10% of width/height)
    const marginX = img.width * 0.1;
    const marginY = img.height * 0.1;
    
    for (let i = 0; i < samplePoints; i++) {
        // Sample from the center area only, ignoring margins
        const x = Math.floor(random(marginX, img.width - marginX));
        const y = Math.floor(random(marginY, img.height - marginY));
        const pixelColor = img.get(x, y);
        
        if (alpha(pixelColor) > transparencyThreshold) {
            validColors.push([
                red(pixelColor),
                green(pixelColor),
                blue(pixelColor)
            ]);
        }
    }
    
    // If we found valid colors, return the first one
    // Otherwise return a default color
    return validColors.length > 0 ? validColors[0] : [255, 255, 255];
}

const colorSets = [[]];  // Will be populated with image colors

function calculateMargin() {
    MARGIN = Math.min(windowWidth, windowHeight) * 0.1;
}

function calculateImageDimensions() {
    const aspectRatio = 326/446;  // Original aspect ratio
    const maxWidth = windowWidth;
    const maxHeight = windowHeight;
    
    // Calculate dimensions that maintain aspect ratio while fitting in the window
    let rectWidth, rectHeight;
    if (maxWidth / maxHeight > aspectRatio) {
        // Height is the limiting factor
        rectHeight = maxHeight;
        rectWidth = rectHeight * aspectRatio;
    } else {
        // Width is the limiting factor
        rectWidth = maxWidth;
        rectHeight = rectWidth / aspectRatio;
    }
    
    // Calculate image dimensions (10.5% larger than rectangle)
    const imageWidth = rectWidth * 1.105;
    const imageHeight = rectHeight * 1.105;
    
    return {
        rectWidth,
        rectHeight,
        imageWidth,
        imageHeight
    };
}

function preload() {
    calculateMargin();
    let dimensions = calculateImageDimensions();
    
    let imageNames = [
        "hatStripe.png", "hat.png", "pants.png", "hands.png", 
        "cuffRight.png", "cuffLeft.png", "scarf7.png", "scarf6.png", 
        "scarf5.png", "scarf4.png", "scarf3.png", "scarf2.png", 
        "scarf1.png", "mouth.png", "rightEye.png", "leftEye.png", 
        "face.png"
    ];
    
    for (let i = 0; i < imageNames.length; i++) {
        loadImage(imageNames[i], img => {
            let scaleFactor = dimensions.imageHeight / img.height;
            img.resize(img.width * scaleFactor, img.height * scaleFactor);
            images[i] = img;
            // Extract color from the image and add it to the color set
            colorSets[0][i] = extractDominantColor(img);
        });
    }
}

function getCurrentAttractMode() {
    if (streamGroups.length === 0 || streamGroups[0].length === 0) {
        return true;
    }
    return streamGroups[0][0].attractMode;
}

function generateStreams() {
    let areaRatio = (windowWidth * windowHeight) / REF_AREA;
    let adjustedNumOfStreams = Math.round(numOfStreams * areaRatio);

    // Distribution percentages for each image (must add up to 1.0)
    const percentages = [
        0.03,  // hatStripe.png
        0.08,  // hat.png
        0.08,  // pants.png
        0.06,  // hands.png
        0.04,  // cuffRight.png
        0.04,  // cuffLeft.png
        0.07,  // scarf7.png
        0.07,  // scarf6.png
        0.07,  // scarf5.png
        0.05,  // scarf4.png
        0.05,  // scarf3.png
        0.07,  // scarf2.png
        0.07,  // scarf1.png
        0.04,  // mouth.png
        0.02,  // rightEye.png
        0.02,  // leftEye.png
        0.12   // face.png
    ];  // Total: 1.0 (100%)

    desiredStreamCounts = [];

    for (let j = 0; j < percentages.length; j++) {
        let desiredCountForImage = Math.round(adjustedNumOfStreams * percentages[j]);
        desiredStreamCounts.push(desiredCountForImage);
    }
    
    totalStreamsToGenerate = adjustedNumOfStreams;
}

function setup() {
    createCanvas(windowWidth, windowHeight);
    imgCenter = createVector(width / 2, height / 2);
    background(0, 0, 0);
    
    for (let i = 0; i < 17; i++) {
        streamGroups.push([]);
    }

    generateStreams();
    // Wait a short time to ensure colors are extracted before setting selectedColorSet
    setTimeout(() => {
        selectedColorSet = colorSets[0];
    }, 100);
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    imgCenter.set(width / 2, height / 2);

    calculateMargin();
    let dimensions = calculateImageDimensions();
    
    for (let i = 0; i < images.length; i++) {
        let img = images[i];
        if (img) {
            let scaleFactor = dimensions.imageHeight / img.height;
            img.resize(img.width * scaleFactor, img.height * scaleFactor);
        }
    }
    
    imgCenter.set(width / 2, height / 2);
    
    generateStreams();
}

function isOverAnyImageCached(point) {
    let cacheKey = `${point.x},${point.y}`;

    if (pointImageOverlapCache.hasOwnProperty(cacheKey)) {
        return pointImageOverlapCache[cacheKey];
    }

    let result = isOverAnyImage(point);
    pointImageOverlapCache[cacheKey] = result;

    return result;
}

function draw() {
    if (!selectedColorSet) return;
    
    background(0, 0, 0);
    pointImageOverlapCache = {};
    // drawTransparentCircle();

    if (isColorCycling) {
        baseHue = (baseHue + COLOR_CYCLE_SPEED) % 360;
        selectedColorSet = generateColorSet();
        updateStreamColors();
    }

    adjustStreams();

    for (let streams of streamGroups) {
        for (let s of streams) {
            s.update();
            s.display();
        }
    }
}

function adjustStreams() {
    if (!selectedColorSet) return;

    for (let j = 0; j < 17; j++) {
        while (streamGroups[j].length < desiredStreamCounts[j]) {
            let samplePoint = streamGroups[j].length > 0 ? random(random(streamGroups[j]).points) : null;
            streamGroups[j].push(new Stream(selectedColorSet[j], j, samplePoint));
        }

        while (streamGroups[j].length > desiredStreamCounts[j]) {
            let lastStream = streamGroups[j][streamGroups[j].length - 1];
            if (lastStream) {
                lastStream.fade();
                if (lastStream.alpha <= 0) {
                    streamGroups[j].pop();
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }
}

function drawTransparentCircle() {
    fill(255, 255, 255, 30);
    noStroke();

    ellipse(width / 2, height / 2, circleDiameter * 2.1);
    ellipse(width / 2, height / 2, circleDiameter * 1.9);
    ellipse(width / 2, height / 2, circleDiameter * 1.7);
    ellipse(width / 2, height / 2, circleDiameter * 1.5);
    ellipse(width / 2, height / 2, circleDiameter * 1.3);
    ellipse(width / 2, height / 2, circleDiameter * 1.1);
    ellipse(width / 2, height / 2, circleDiameter * .9);
    ellipse(width / 2, height / 2, circleDiameter * .7);
}

function isInsideCircle(point) {
    return dist(point.x, point.y, imgCenter.x, imgCenter.y) <= circleDiameter / 1.6;
}

function isInsideRect(point) {
    const dimensions = calculateImageDimensions();
    const rectLeft = imgCenter.x - dimensions.rectWidth/2;
    const rectRight = imgCenter.x + dimensions.rectWidth/2;
    const rectTop = imgCenter.y - dimensions.rectHeight/2;
    const rectBottom = imgCenter.y + dimensions.rectHeight/2;
    
    return point.x >= rectLeft && 
           point.x <= rectRight && 
           point.y >= rectTop && 
           point.y <= rectBottom;
}

function mousePressed() {
    isColorCycling = !isColorCycling;
}

function keyPressed() {
    if (key >= '1' && key <= '4') {
        let paletteIndex = parseInt(key) - 1;
        selectedColorSet = colorSets[paletteIndex];
        updateStreamColors();
    }
}

function updateStreamColors() {
    for (let j = 0; j < streamGroups.length; j++) {
        for (let stream of streamGroups[j]) {
            stream.color = selectedColorSet[j];
        }
    }
}

// function resetStreams() {
//     for (let j = 0; j < 4; j++) {
//         streamGroups[j] = [];
//     }
//     generateStreams();
// }

class Stream {
    constructor(color, assignedImageIdx, startPoint = null) {
        this.color = color;
        this.points = [];
        this.noiseOffset = random(1000);
        this.currentAngle = random(TWO_PI);
        this.attractMode = getCurrentAttractMode();
        this.assignedImageIdx = assignedImageIdx;
        this.initStream(startPoint);
        this.insideImage = this.isOverAssignedImage(this.points[0]);
        this.alpha = 255;
    }
    
    changeMode() {
        this.attractMode = !this.attractMode;
    }

    fade() {
        this.alpha -= 200;
    }
  
    isOverAnyImage(point) {
        return isOverAnyImageCached(point);
    }

    initStream(startPoint = null) {
        if (startPoint) {
            this.points.push(startPoint);
        } else {
            let startX, startY;
            let attempts = 0;
            const maxAttempts = 100;
            
            do {
                // Get the assigned image
                const img = images[this.assignedImageIdx];
                if (!img) break;
                
                // Calculate the image's position on canvas
                const imgX = width / 2 - img.width / 2;
                const imgY = height / 2 - img.height / 2;
                
                // Generate random point within the image bounds
                startX = random(imgX, imgX + img.width);
                startY = random(imgY, imgY + img.height);
                
                attempts++;
            } while (
                attempts < maxAttempts && 
                (!this.isOverAssignedImage(createVector(startX, startY)) || 
                !isInsideRect(createVector(startX, startY)))
            );
            
            // If we couldn't find a valid point, fall back to random position
            if (attempts >= maxAttempts) {
                startX = random(width);
                startY = random(height);
            }
            
            this.points.push(createVector(startX, startY));
        }
    }

    isOutsideAllImages(point) {
        return !this.isOverAnyImage(point);
    }

    isOverAnyImage(point) {
        for (let img of images) {
            if (this.isOverImage(point, img)) return true;
        }
        return false;
    }

    isOverAssignedImage(point) {
        return this.isOverImage(point, images[this.assignedImageIdx]);
    }

    isOverImage(point, img) {
        let imgX = point.x - (width / 2 - img.width / 2);
        let imgY = point.y - (height / 2 - img.height / 2);
        if (imgX >= 0 && imgX < img.width && imgY >= 0 && imgY < img.height) {
            let pixelColor = img.get(imgX, imgY);
            return alpha(pixelColor) > transparencyThreshold && isInsideRect(point);
        }
        return false;
    }
  
    stayWithinBounds(point) {
        const buffer = 5;
        if (point.x <= buffer || point.x >= width - buffer) {
            this.currentAngle = PI - this.currentAngle;
        }
        if (point.y <= buffer || point.y >= height - buffer) {
            this.currentAngle = -this.currentAngle;
        }
    }

    get totalStreamsCount() {
        let totalStreams = 0;
        for (let streams of streamGroups) {
            totalStreams += streams.length;
        }
        return totalStreams;
    }

    update() {
        let lastPoint = this.points[this.points.length - 1];
        let newPoint;

        let speed = this.attractMode ? BASE_SPEED + LOG_SCALE_FACTOR * Math.log(this.totalStreamsCount + 1) : 12;

        if (this.attractMode) {
            if (this.isOutsideAllImages(lastPoint) || this.insideImage || this.isOverAssignedImage(lastPoint)) {
                this.currentAngle = this.calculateAngleTowardsImage(lastPoint, this.assignedImageIdx);
            }
        } else {
            if (this.isOverAnyImage(lastPoint)) {
                this.currentAngle = this.calculateAngleAwayFromClosestImageCenter(lastPoint);
            }
        }

        let angleVariation = map(noise(this.noiseOffset), 0, .025, -PI, PI);
        this.currentAngle += angleVariation;

        newPoint = p5.Vector.fromAngle(this.currentAngle).mult(speed).add(lastPoint);

        if (this.attractMode && this.insideImage && !this.isOverAssignedImage(newPoint)) {
            this.currentAngle += PI;
            newPoint = p5.Vector.fromAngle(this.currentAngle).mult(speed).add(lastPoint);
        }

        this.stayWithinBounds(newPoint);

        this.points.push(newPoint);
        this.noiseOffset += 0.001;

        if (this.points.length > 100) {
            this.points.shift();
        }

        this.insideImage = this.isOverAssignedImage(lastPoint);
    }

    calculateAngleAwayFromClosestImageCenter(point) {
        let closestDistance = Infinity;
        let closestImageCenter;

        for (let img of images) {
            let distance = dist(point.x, point.y, imgCenter.x, imgCenter.y);
            if (distance < closestDistance && this.isOverImage(point, img)) {
                closestDistance = distance;
                closestImageCenter = imgCenter;
            }
        }

        if (closestImageCenter) {
            return p5.Vector.sub(point, closestImageCenter).heading();
        }
        
        return random(TWO_PI);
    }

    calculateAngleTowardsImage(point, imgIdx) {
        if (this.insideImage) {
            return random(TWO_PI);
        }
        
        // Get the assigned image
        const img = images[imgIdx];
        if (!img) return random(TWO_PI);
        
        // Calculate image bounds
        const imgX = width / 2 - img.width / 2;
        const imgY = height / 2 - img.height / 2;
        
        // Calculate a random point within the image bounds
        const targetX = random(imgX, imgX + img.width);
        const targetY = random(imgY, imgY + img.height);
        
        // Calculate angle towards the random point in the image
        return atan2(targetY - point.y, targetX - point.x);
    }

    display() {
        noFill();
        let alphaValue = this.alpha;
        if (!this.isOverAssignedImage(this.points[this.points.length - 1])) {
            alphaValue = this.alpha * 0.3; // Reduce brightness to 30% when not over assigned image
        }
        stroke(this.color[0], this.color[1], this.color[2], alphaValue);
        strokeWeight(.5);
        beginShape();
        for (let pt of this.points) {
            vertex(pt.x, pt.y)
        }
        endShape();
    }
}

function rgbToHsb(r, g, b) {
    r = r / 255;
    g = g / 255;
    b = b / 255;
    
    let max = Math.max(r, g, b);
    let min = Math.min(r, g, b);
    let d = max - min;
    
    let h;
    if (max === min) {
        h = 0;
    } else if (max === r) {
        h = (60 * ((g - b) / d) + 360) % 360;
    } else if (max === g) {
        h = (60 * ((b - r) / d) + 120) % 360;
    } else {
        h = (60 * ((r - g) / d) + 240) % 360;
    }
    
    let s = max === 0 ? 0 : d / max;
    let v = max;
    
    return [h, s * 100, v * 100];
}

function generateColorSet() {
    if (!isColorCycling) {
        return colorSets[0];
    }
    
    let colors = [];
    for (let i = 0; i < 17; i++) {
        let originalColor = colorSets[0][i];
        let [h, s, v] = rgbToHsb(originalColor[0], originalColor[1], originalColor[2]);
        let newHue = (h + baseHue) % 360;
        colors.push(hsbToRgb(newHue, s, v));
    }
    return colors;
}

function hsbToRgb(h, s, v) {
    h = h % 360;
    s = s / 100;
    v = v / 100;
    
    let c = v * s;
    let x = c * (1 - Math.abs((h / 60) % 2 - 1));
    let m = v - c;
    
    let r, g, b;
    
    if (h < 60) {
        [r, g, b] = [c, x, 0];
    } else if (h < 120) {
        [r, g, b] = [x, c, 0];
    } else if (h < 180) {
        [r, g, b] = [0, c, x];
    } else if (h < 240) {
        [r, g, b] = [0, x, c];
    } else if (h < 300) {
        [r, g, b] = [x, 0, c];
    } else {
        [r, g, b] = [c, 0, x];
    }
    
    return [
        Math.round((r + m) * 255),
        Math.round((g + m) * 255),
        Math.round((b + m) * 255)
    ];
}
    </script>
</body>

</html>